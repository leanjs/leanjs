"use strict";(self.webpackChunk_leanjs_website=self.webpackChunk_leanjs_website||[]).push([[195],{5318:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>u});var o=t(7378);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function p(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?p(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):p(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},p=Object.keys(e);for(o=0;o<p.length;o++)t=p[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var p=Object.getOwnPropertySymbols(e);for(o=0;o<p.length;o++)t=p[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=o.createContext({}),l=function(e){var n=o.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},c=function(e){var n=l(e.components);return o.createElement(s.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,p=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=l(t),u=a,h=d["".concat(s,".").concat(u)]||d[u]||m[u]||p;return t?o.createElement(h,r(r({ref:n},c),{},{components:t})):o.createElement(h,r({ref:n},c))}));function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var p=t.length,r=new Array(p);r[0]=d;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i.mdxType="string"==typeof e?e:a,r[1]=i;for(var l=2;l<p;l++)r[l]=t[l];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}d.displayName="MDXCreateElement"},911:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>m,frontMatter:()=>p,metadata:()=>i,toc:()=>l});var o=t(5773),a=(t(7378),t(5318));const p={},r="@leanjs/next",i={unversionedId:"next/README",id:"next/README",title:"@leanjs/next",description:"Installation",source:"@site/../packages/next/README.md",sourceDirName:"next",slug:"/next/",permalink:"/packages/next/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"@leanjs/react-router",permalink:"/packages/react-router/"},next:{title:"@leanjs/vue",permalink:"/packages/vue/"}},s={},l=[{value:"Installation",id:"installation",level:2},{value:"Basic usage",id:"basic-usage",level:2},{value:"<code>HostProvider</code>",id:"hostprovider",level:3},{value:"Components",id:"components",level:2},{value:"<code>Host</code>",id:"host",level:3},{value:"<code>app</code> - required prop",id:"app---required-prop",level:4},{value:"<code>errorComponent</code> prop - optional",id:"errorcomponent-prop---optional",level:4},{value:"<code>fallback</code> prop - optional",id:"fallback-prop---optional",level:4}],c={toc:l};function m(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,o.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"leanjsnext"},"@leanjs/next"),(0,a.kt)("h2",{id:"installation"},"Installation"),(0,a.kt)("p",null,"If your Nextjs app is in a monorepo (recommended) execute the following command at the root of your repository:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sh"},"yarn add -W @leanjs/next @leanjs/react @leanjs/core\n")),(0,a.kt)("p",null,"then in the ",(0,a.kt)("inlineCode",{parentName:"p"},"package.json")," of your Nextjs app add the following ",(0,a.kt)("inlineCode",{parentName:"p"},"peerDependencies"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'"peerDependencies": {\n  "@leanjs/core": "*",\n  "@leanjs/next": "*",\n  "@leanjs/react": "*"\n}\n')),(0,a.kt)("p",null,"If your Nextjs app is not in a monorepo, then run the following command instead of the above:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sh"},"yarn add @leanjs/next @leanjs/react @leanjs/core\n")),(0,a.kt)("h2",{id:"basic-usage"},"Basic usage"),(0,a.kt)("h3",{id:"hostprovider"},(0,a.kt)("inlineCode",{parentName:"h3"},"HostProvider")),(0,a.kt)("p",null,"You have to add a ",(0,a.kt)("inlineCode",{parentName:"p"},"HostProvider")," at the root of your component tree in ",(0,a.kt)("inlineCode",{parentName:"p"},"pages/_app.tsx"),". ",(0,a.kt)("strong",{parentName:"p"},"Heads up!")," ",(0,a.kt)("inlineCode",{parentName:"p"},"HostProvider")," is not exported from ",(0,a.kt)("inlineCode",{parentName:"p"},"@leanjs/next"),". Learn more about the ",(0,a.kt)("a",{parentName:"p",href:"/packages/react/#hostprovider"},(0,a.kt)("inlineCode",{parentName:"a"},"HostProvider")),"."),(0,a.kt)("p",null,"Example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},'import type { AppProps } from "next/app";\nimport React from "react";\n// react runtime package created within your org\nimport { HostProvider } from "@my-org/react-runtime";\n// shared runtime package created within your org\nimport { createRuntime } from "@my-org/shared-runtime";\n\nconst runtime = createRuntime();\n\nconst App = ({ Component, pageProps }: AppProps) => (\n  <HostProvider runtime={runtime}>\n    <Component {...pageProps} />\n  </HostProvider>\n);\n\nexport default App;\n')),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Read ",(0,a.kt)("a",{parentName:"p",href:"/packages/core#basic-usage"},"@leanjs/core")," if you have not already created your own ",(0,a.kt)("inlineCode",{parentName:"p"},"createRuntime")," function")),(0,a.kt)("h2",{id:"components"},"Components"),(0,a.kt)("p",null,"The examples in this section are based on the following project structure:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"my-monorepo/\n\u251c\u2500 apps/\n\u2502  \u251c\u2500 nextjs-host/\n\u2502  \u2502  \u251c\u2500 next.config.js\n\u251c\u2500 composable-apps/\n\u2502  \u251c\u2500 react-app-1/\n\u2502  \u2502  \u251c\u2500 package.json\n\u2502  \u2502  \u251c\u2500 src/\n\u2502  \u2502  \u2502  \u251c\u2500 ReactApp1.tsx\n\u2502  \u2502  \u2502  \u251c\u2500 index.ts\n\u251c\u2500 package.json\n")),(0,a.kt)("h3",{id:"host"},(0,a.kt)("inlineCode",{parentName:"h3"},"Host")),(0,a.kt)("p",null,"It hosts a composable app in a Next host."),(0,a.kt)("h4",{id:"app---required-prop"},(0,a.kt)("inlineCode",{parentName:"h4"},"app")," - required prop"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"app")," prop expects a ",(0,a.kt)("inlineCode",{parentName:"p"},"GetComposableApp")," type. You can ",(0,a.kt)("inlineCode",{parentName:"p"},"import")," a ",(0,a.kt)("inlineCode",{parentName:"p"},"GetComposableApp")," from any ",(0,a.kt)("inlineCode",{parentName:"p"},"export default createApp()")," function, for instance:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},'// my-monorepo/composable-apps/react-app-1/src/index.ts\n\nimport { createApp } from "@leanjs/react";\n\nimport { ReactApp1 } from "./ReactApp1";\n\nexport default createApp(ReactApp1);\n')),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"In this example the composable app is a React app. However, the Nextjs ",(0,a.kt)("inlineCode",{parentName:"p"},"<Host>")," component can host any composable app, e.g. Vue.")),(0,a.kt)("p",null,"then pass it to the ",(0,a.kt)("inlineCode",{parentName:"p"},"Host")," component in a Next.js app:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},'// my-monorepo/apps/nextjs-host/pages/index.tsx\n\nimport type { NextPage } from "next";\nimport { Host } from "@leanjs/next";\n\n// this composable app is bundled and deployed along with the Nextjs app\nimport ReactApp1 from "@my-org/react-app-1";\n\nconst Home: NextPage = () => {\n  return (\n    <>\n      <h1>Nextjs Host</h1>\n      <Host app={ReactApp1} />\n    </>\n  );\n};\n\nexport default Home;\n')),(0,a.kt)("p",null,"You can also pass a function to the ",(0,a.kt)("inlineCode",{parentName:"p"},"Host")," component that returns a dynamic import to lazy load a composable app:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},'// my-monorepo/apps/nextjs-host/pages/index.tsx\n\nimport type { NextPage } from "next";\nimport { Host } from "@leanjs/next";\n\nconst Home: NextPage = () => {\n  return (\n    <>\n      <h1>Nextjs Host</h1>\n      <Host\n        app={() => {\n          // this composable app is bundled in a separate chunk\n          // but it\'s still built and deployed along with the Nextjs app\n          return import("@my-org/react-app-1");\n        }}\n      />\n    </>\n  );\n};\n\nexport default Home;\n')),(0,a.kt)("p",null,"Alternatively, you can pass an object to the ",(0,a.kt)("inlineCode",{parentName:"p"},"app")," prop with a ",(0,a.kt)("inlineCode",{parentName:"p"},"packageName")," key which value is the field ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," in the package.json of the composable app that you want to host. In this case, the ",(0,a.kt)("inlineCode",{parentName:"p"},"Host")," component will try to fetch the ",(0,a.kt)("inlineCode",{parentName:"p"},"mount")," function from the remote ",(0,a.kt)("inlineCode",{parentName:"p"},"origin")," specified in ",(0,a.kt)("inlineCode",{parentName:"p"},'<HostProvider origin=" \ud83d\udc49 HERE \ud83d\udc48 " runtime={runtime}>')," (see ",(0,a.kt)("a",{parentName:"p",href:"/packages/react/#origin-prop---optional"},"origin prop")," to know more). For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},'// my-monorepo/apps/nextjs-host/pages/index.tsx\n\nimport type { NextPage } from "next";\nimport { Host } from "@leanjs/next";\n\nconst Home: NextPage = () => {\n  return (\n    <>\n      <h1>Nextjs Host</h1>\n      {/* in this case, the composable app is neither built nor deployed\n          along with the Next.js host */}\n      <Host app={{ packageName: "@my-org/react-app-1" }} />\n    </>\n  );\n};\n\nexport default Home;\n')),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"Fetching from a remote ",(0,a.kt)("inlineCode",{parentName:"p"},"origin")," only works with Webpack v5 because this feature uses Module Federation under the hood. You need to add a ",(0,a.kt)("a",{parentName:"p",href:"/packages/webpack/#hostwebpackplugin"},"HostWebpackPlugin")," to your ",(0,a.kt)("inlineCode",{parentName:"p"},"next.config.js")," to enable this feature. If this feature is enabled you need to build and deploy your composable apps independently. See ",(0,a.kt)("a",{parentName:"p",href:"/packages/aws/"},"@leanjs/aws")," to deploy your composable apps to AWS.")),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"You can still pass an ",(0,a.kt)("inlineCode",{parentName:"p"},"import")," (either dynamic or static) to the ",(0,a.kt)("inlineCode",{parentName:"p"},"app")," prop of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Host")," component and configure Webpack to fetch it from a remote origin by changing the configuration of your ",(0,a.kt)("inlineCode",{parentName:"p"},"HostWebpackPlugin"),".")),(0,a.kt)("p",null,"Tip example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},'// my-monorepo/apps/nextjs-host/next.config.js\nconst { HostWebpackPlugin } = require("@leanjs/webpack");\n\nmodule.exports = {\n  webpack: (config) => {\n    config.plugins.push(\n      new HostWebpackPlugin({\n        remotes: {\n          // these packages are not built along with the Nextjs app\n          // but downloaded from a remote origin\n          packages: ["@my-org/react-app-1"],\n        },\n      })\n    );\n\n    return config;\n  },\n};\n')),(0,a.kt)("p",null,"then in your Next.js app:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},'// my-monorepo/apps/nextjs-host/pages/index.tsx\n\nimport type { NextPage } from "next";\nimport { Host } from "@leanjs/next";\n\n// this composable app is neither bundled nor deployed along with the Nextjs app\n// because of the above remote: { packages: ["@my-org/react-app-1"] }\n// in the next.config.js HostWebpackPlugin\nimport ReactApp1 from "@my-org/react-app-1";\n\nconst Home: NextPage = () => {\n  return (\n    <>\n      <h1>Nextjs Host</h1>\n      <Host app={ReactApp1} />\n    </>\n  );\n};\n\nexport default Home;\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Pro-tip"),"\nConfigure your ",(0,a.kt)("inlineCode",{parentName:"p"},"remotes")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"HostWebpackPlugin")," on development only. This way no CI/CD changes are required. It also reduces the build time of your monolith in development since these packages are excluded from the monolith build. Last but not least, you can experiment with micro-frontends in development without changing how you implement and host your apps."),(0,a.kt)("p",null,"Pro-tip example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},'// my-monorepo/apps/nextjs-host/next.config.js\nconst { HostWebpackPlugin } = require("@leanjs/webpack");\n\nmodule.exports = {\n  webpack: (config) => {\n    config.plugins.push(\n      new HostWebpackPlugin({\n        remotes: {\n          // the following packages are built and deployed along with\n          // the Nextjs app on production, but not during development.\n          packages:\n            process.env.NODE_ENV === "production"\n              ? []\n              : ["@my-org/react-app-1"],\n        },\n      })\n    );\n\n    return config;\n  },\n};\n')),(0,a.kt)("h4",{id:"errorcomponent-prop---optional"},(0,a.kt)("inlineCode",{parentName:"h4"},"errorComponent")," prop - optional"),(0,a.kt)("p",null,"React component displayed when a hosted ",(0,a.kt)("inlineCode",{parentName:"p"},"app")," errors and the error is not handled by the ",(0,a.kt)("inlineCode",{parentName:"p"},"app"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"type ErrorComponent = null | (props: { error: Error }) => ReactElement;\n")),(0,a.kt)("p",null,"If the ",(0,a.kt)("inlineCode",{parentName:"p"},"errorComponent")," prop is not passed then the ",(0,a.kt)("inlineCode",{parentName:"p"},"Host")," component will catch the error and display a default error component. The default behaviour is to always catch errors within the boundaries of the host."),(0,a.kt)("p",null,"If ",(0,a.kt)("inlineCode",{parentName:"p"},"null")," is passed to the ",(0,a.kt)("inlineCode",{parentName:"p"},"errorComponent")," prop then the ",(0,a.kt)("inlineCode",{parentName:"p"},"Host")," component will throw any errors not handled by the hosted ",(0,a.kt)("inlineCode",{parentName:"p"},"app"),". This is useful if you want to display a single error message for a group of elements in case of error, e.g.:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"<MyErrorBoundary>\n  <Host app={exampleApp1} errorComponent={null} />\n  <Host app={exampleApp2} errorComponent={null} />\n  <h1>Don't show this if either of the above hosted apps fail</h1>\n</MyErrorBoundary>\n")),(0,a.kt)("h4",{id:"fallback-prop---optional"},(0,a.kt)("inlineCode",{parentName:"h4"},"fallback")," prop - optional"),(0,a.kt)("p",null,"React element displayed when a ",(0,a.kt)("inlineCode",{parentName:"p"},"<Host>")," component is fetching a remote app."))}m.isMDXComponent=!0}}]);