"use strict";(self.webpackChunk_leanjs_website=self.webpackChunk_leanjs_website||[]).push([[820],{5318:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(7378);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(n),m=o,h=p["".concat(s,".").concat(m)]||p[m]||d[m]||r;return n?a.createElement(h,i(i({ref:t},u),{},{components:n})):a.createElement(h,i({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var c=2;c<r;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},6711:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var a=n(5773),o=(n(7378),n(5318));const r={},i="@leanjs/core",l={unversionedId:"core/README",id:"core/README",title:"@leanjs/core",description:"This runtime enables micro-apps to share state or execution context in a controlled manner, keeping your micro-apps performant and maintainable. By default nothing is shared. You can read more about the why of this package in this post.",source:"@site/../packages/core/README.md",sourceDirName:"core",slug:"/core/",permalink:"/packages/core/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"@leanjs/cli",permalink:"/packages/cli/"},next:{title:"@leanjs/next",permalink:"/packages/next/"}},s={},c=[{value:"Installation",id:"installation",level:2},{value:"Usage",id:"usage",level:2},{value:"Guiding principles",id:"guiding-principles",level:3},{value:"Basic",id:"basic",level:3},{value:"With execution context",id:"with-execution-context",level:4},{value:"API",id:"api",level:3},{value:"<code>configureRuntime</code>",id:"configureruntime",level:4},{value:"onError - required function",id:"onerror---required-function",level:5},{value:"context - optional object",id:"context---optional-object",level:5},{value:"<code>createRuntime</code>",id:"createruntime",level:4},{value:"<code>booted</code>",id:"booted",level:4},{value:"<code>state</code>",id:"state",level:4},{value:"<code>subscribe</code>",id:"subscribe",level:4},{value:"<code>context</code>",id:"context",level:4},{value:"<code>on</code>",id:"on",level:4},{value:"<code>load</code>",id:"load",level:4},{value:"<code>loaded</code>",id:"loaded",level:4},{value:"<code>loader</code>",id:"loader",level:4}],u={toc:c};function d(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"leanjscore"},"@leanjs/core"),(0,o.kt)("h1",{id:"runtime"},"Runtime"),(0,o.kt)("p",null,"This ",(0,o.kt)("inlineCode",{parentName:"p"},"runtime")," enables micro-apps to share state or execution context in a controlled manner, keeping your micro-apps performant and maintainable. By default nothing is shared. You can read more about ",(0,o.kt)("a",{parentName:"p",href:"https://alexlobera.com/sharing-state-in-micro-frontends-at-runtime/"},"the why of this package in this post"),"."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"runtime")," is created in two steps:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"configureRuntime"),". In a distributed architecture there are many places where a runtime could be created. For instance, each micro-app will create a ",(0,o.kt)("inlineCode",{parentName:"p"},"runtime")," if they run in isolation. However, when micro-apps are composed into a single app, only one ",(0,o.kt)("inlineCode",{parentName:"p"},"runtime")," should be created and shared across all of them. The ",(0,o.kt)("inlineCode",{parentName:"p"},"runtime")," can be created in more than one place but the configuration of it should be the same for all of them. Don't invoke ",(0,o.kt)("inlineCode",{parentName:"p"},"configureRuntime")," more than once in a project. By project I mean in your whole front-end architecture.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"createRuntime"),". Invoking ",(0,o.kt)("inlineCode",{parentName:"p"},"configureRuntime")," returns a function called ",(0,o.kt)("inlineCode",{parentName:"p"},"createRuntime")," which creates a ",(0,o.kt)("inlineCode",{parentName:"p"},"runtime")," when invoked. You can use ",(0,o.kt)("inlineCode",{parentName:"p"},"createRuntime")," in each distributed micro-app. Remember, there should be only one shared ",(0,o.kt)("inlineCode",{parentName:"p"},"runtime")," in the runtime program. ",(0,o.kt)("inlineCode",{parentName:"p"},"createRuntime")," is not a singleton so you are responsible for making sure no more than one ",(0,o.kt)("inlineCode",{parentName:"p"},"runtime")," is created."))),(0,o.kt)("p",null,"There are two things that you can share in a ",(0,o.kt)("inlineCode",{parentName:"p"},"runtime"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"State. By design, we don't facilitate creating complex data structures. The ",(0,o.kt)("inlineCode",{parentName:"li"},"runtime")," shared state is a flatten data structure, it doesn't support nested states unlike Redux for instance. However, you can add any object in a given state property. You can think of the ",(0,o.kt)("inlineCode",{parentName:"li"},"runtime")," state as a ",(0,o.kt)("strong",{parentName:"li"},"read-write")," hash table."),(0,o.kt)("li",{parentName:"ul"},"Execution context. It contains instances of code that we want to share. E.g. a WebSocket client that holds WS connections. You can think of it as a ",(0,o.kt)("strong",{parentName:"li"},"read-only")," hash table.")),(0,o.kt)("h2",{id:"installation"},"Installation"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"yarn add @leanjs/core")),(0,o.kt)("h2",{id:"usage"},"Usage"),(0,o.kt)("h3",{id:"guiding-principles"},"Guiding principles"),(0,o.kt)("p",null,"When designing your shared runtime follow these recommendations:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Less is more. The more things shared between micro-apps the higher coupling. Use this ",(0,o.kt)("inlineCode",{parentName:"li"},"runtime")," sparingly."),(0,o.kt)("li",{parentName:"ul"},"Make the ",(0,o.kt)("inlineCode",{parentName:"li"},"runtime")," type-safety. Only types defined in the configuration of the ",(0,o.kt)("inlineCode",{parentName:"li"},"runtime")," are allowed. This way developers in different teams know what can be shared and what can't be shared. Use TypeScript."),(0,o.kt)("li",{parentName:"ul"},"Centralise the configuration of the ",(0,o.kt)("inlineCode",{parentName:"li"},"runtime"),". Anyone can use the ",(0,o.kt)("inlineCode",{parentName:"li"},"runtime")," but only a few people should be able to change what can be shared. Execute ",(0,o.kt)("inlineCode",{parentName:"li"},"configureRuntime")," in its own repo with restricted access, or use CODEOWNERS if in a monorepo, then export it for anyone to use.")),(0,o.kt)("h3",{id:"basic"},"Basic"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'const defaultState = {\n  locale: "en",\n};\n\nconst { createRuntime } = configureRuntime(defaultState)({\n  onError: (error) => {}, // required, log the error properly, e.g. Sentry, Datadog, etc\n});\n')),(0,o.kt)("h4",{id:"with-execution-context"},"With execution context"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'const defaultState = {\n  locale: "en",\n};\n\nconst { createRuntime } = configureRuntime(defaultState)({\n  onError: () => {}, // required, log the error properly, e.g. Sentry, Datadog, etc\n  context: {\n    eventEmitter: new MyEventEmitter(),\n  },\n});\n')),(0,o.kt)("h3",{id:"api"},"API"),(0,o.kt)("h4",{id:"configureruntime"},(0,o.kt)("inlineCode",{parentName:"h4"},"configureRuntime")),(0,o.kt)("p",null,"It's a function with two curried arguments. The argument of the first function receives the default state. The argument of the second function is the configuration of the runtime."),(0,o.kt)("p",null,"The default state must be an object. The keys of the objects are used at runtime to validate access to the shared state. For instance, given the following default state:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const defaultState = {\n  locale: "en",\n};\n')),(0,o.kt)("p",null,"if a consumer of the ",(0,o.kt)("inlineCode",{parentName:"p"},"runtime")," tries to read or write a shared state property named ",(0,o.kt)("inlineCode",{parentName:"p"},"foo"),", the ",(0,o.kt)("inlineCode",{parentName:"p"},"runtime")," will throw an error. Only ",(0,o.kt)("inlineCode",{parentName:"p"},"locale")," is a valid shared state property. In other words, the default state is also used as a runtime validator. This behaviour can't be disabled."),(0,o.kt)("p",null,"If you use TypeScript, the ",(0,o.kt)("inlineCode",{parentName:"p"},"runtime")," will infer the types of the shared state from the default state. For instance, in the previous ",(0,o.kt)("inlineCode",{parentName:"p"},"defaultState")," TypeScript will only allow consumers of your shared state to read and write a state property called ",(0,o.kt)("inlineCode",{parentName:"p"},"locale")," and its only possible value will be a string."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"configureRuntime")," is a generic function so you can pass a TS type definition for your shared state. This is useful if your default state values don't match all the possible values of your shared state, e.g."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"interface SharedState {\n  locale?: string;\n}\n\nconst defaultState = {\n  locale: undefined,\n};\n\n// without passing a concrete type to the generic `configureRuntime`,\n// locale could only be assigned to undefined because of the defaultState value\nconst { createRuntime } = configureRuntime<SharedState>(defaultState)({\n  onError: () => {}, // required, log the error properly, e.g. Sentry, Datadog, etc\n});\n")),(0,o.kt)("h5",{id:"onerror---required-function"},"onError - required function"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"runtime")," makes any asynchronous code internally look synchronous externally. This means that you won't be able to catch all the promises that might be generated. The ",(0,o.kt)("inlineCode",{parentName:"p"},"onError")," function will be invoked whenever there is an errors in the runtime, either sync or async."),(0,o.kt)("h5",{id:"context---optional-object"},"context - optional object"),(0,o.kt)("p",null,"Similarly to ",(0,o.kt)("inlineCode",{parentName:"p"},"defaultState")," each property in this context object argument is used to validate access to the shared context at runtime. In the following example reading a context prop different from ",(0,o.kt)("inlineCode",{parentName:"p"},"serviceX")," will throw a runtime error."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"cosnst { createRuntime } = configureRuntime(defaultState)({\n  onError,\n  context: {\n    serviceX: new ServiceX(),\n  },\n});\n\nconst runtime = createRuntime()\n\n\n// \u2705 reading the following property doesn't throw an error\nruntime.context.serviceX\n\n// \u274c reading the following property will throw an error\nruntime.context.serviceNameNotValid\n")),(0,o.kt)("p",null,"Context is read-only. You can't re-assign values. Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"cosnst { createRuntime } = configureRuntime(defaultState)({\n  onError,\n  context: {\n    serviceX: new ServiceX(),\n  },\n});\n\nconst runtime = createRuntime()\n\n\n// \u274c assigning a new value to a context property will throw an error\nruntime.context.serviceX = new ServiceX()\n")),(0,o.kt)("p",null,"If you use TypeScript, since context can't change, the types of the context values will be inferred by TypeScript as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"cosnst { createRuntime } = configureRuntime(defaultState)({\n  onError,\n  context: {\n    // wsClient1 type is WsClient\n    wsClient1: new WsClient(),\n    // wsClient2 type is WsClient\n    wsClient2: () => new WsClient(),\n    // wsClient3 type is WsClient\n    wsClient3: async () => new WsClient()),\n  },\n});\n")),(0,o.kt)("p",null,"When initialising a context property using a function, e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"wsClient3: async () => new WsClient()),")," the function is executed lazily when the property is read. Context properties that are not a function are executed eagerly, e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"wsClient1: new WsClient(),"),"."),(0,o.kt)("p",null,"In the example above calling ",(0,o.kt)("inlineCode",{parentName:"p"},"createRuntime()")," will return the following runtime:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const runtime = createRuntime();\n\n// runtime.context.wsClient1 has been initialised and it's value is `new WsClient()`\n\n// runtime.context.wsClient2 has not been initialised and it's value is undefined\n\nruntime.context.wsClient2; // this initialises wsClient2 with new WsClient()\n")),(0,o.kt)("p",null,"You can also lazy load code. In the following example, when a micro-app reads ",(0,o.kt)("inlineCode",{parentName:"p"},"runtime.context.wsClient"),", the JavaScript required to execute ",(0,o.kt)("inlineCode",{parentName:"p"},"wsClient")," will be downloaded and executed."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"cosnst { createRuntime } = configureRuntime(defaultState)({\n  onError,\n  context: {\n    wsClient: () => import('./path-to-my-code'),\n  },\n});\n\nconst runtime = createRuntime();\n\nconst wsClient = await runtime.context.wsClient // ./path-to-my-code.js is downloaded\n")),(0,o.kt)("h4",{id:"createruntime"},(0,o.kt)("inlineCode",{parentName:"h4"},"createRuntime")),(0,o.kt)("p",null,"It creates a ",(0,o.kt)("inlineCode",{parentName:"p"},"runtime"),". Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'const defaultState = {\n  locale: "en",\n};\n\nconst { createRuntime } = configureRuntime(defaultState)({\n  onError,\n});\n\nconst runtime = createRuntime();\n')),(0,o.kt)("h4",{id:"booted"},(0,o.kt)("inlineCode",{parentName:"h4"},"booted")),(0,o.kt)("p",null,"Async method that resolves true when all the async context resolves. If any of the async context properties is rejected it resolves false."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"await runtime.booted();\n")),(0,o.kt)("h4",{id:"state"},(0,o.kt)("inlineCode",{parentName:"h4"},"state")),(0,o.kt)("p",null,"It holds the current shared state."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// you can read state\nconst locale = runtime.state.locale;\n\n// you can write state\nruntime.state.locale = "es";\n// subscribers to state.locale are notified\n')),(0,o.kt)("h4",{id:"subscribe"},(0,o.kt)("inlineCode",{parentName:"h4"},"subscribe")),(0,o.kt)("p",null,"It's used to subscribe to state changes. It receives a state property and a callback. When the state property changes the callback is invoked. It returns an ",(0,o.kt)("inlineCode",{parentName:"p"},"unsubscribe")," function. Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'const unsubscribe = runtime.subscribe("locale", (locale) =>\n  console.log(`locale changed ${locale}`)\n);\n')),(0,o.kt)("h4",{id:"context"},(0,o.kt)("inlineCode",{parentName:"h4"},"context")),(0,o.kt)("p",null,"It holds the current shared context. Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const wsClient = runtime.context.wsClient;\n\n// context is read only, the following line throws an error\n// \u274c runtime.context.wsClient = new WsClient()\n")),(0,o.kt)("p",null,"It's not recommended to access the context directly whenever possible. If you want to update some shared state based on an event from the shared context then use the ",(0,o.kt)("inlineCode",{parentName:"p"},"on")," method underneath."),(0,o.kt)("h4",{id:"on"},(0,o.kt)("inlineCode",{parentName:"h4"},"on")),(0,o.kt)("p",null,"This method is used to update shared state based on events from the context."),(0,o.kt)("p",null,"It has two arguments, the context property that you want to use, and a callback function that will receive the context instance and the current state. The callback must return a clean-up function. ",(0,o.kt)("inlineCode",{parentName:"p"},"on")," returns an ",(0,o.kt)("inlineCode",{parentName:"p"},"off")," function which calls the callback clean-up function upon invocation. Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'const off = runtime.on("wsClient", (wsClient, state) => {\n  function updateLocale(value) {\n    state.locale = value;\n  }\n  wsClient?.on("locale-changed", updateLocale);\n\n  return () => {\n    wsClient.off("locale-changed", updateLocale);\n  };\n});\n\noff(); // wsClient.off("locale-changed", updateLocale); is called\n')),(0,o.kt)("h4",{id:"load"},(0,o.kt)("inlineCode",{parentName:"h4"},"load")),(0,o.kt)("p",null,"It loads some value in a given state property. Once a state property is loaded with a value, no other loader will have effect on the given state property. ",(0,o.kt)("inlineCode",{parentName:"p"},"load")," is async. Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'const locale = await runtime.load("locale", fetchLocale);\n// locale equals runtime.state.locale\n')),(0,o.kt)("p",null,"When calling ",(0,o.kt)("inlineCode",{parentName:"p"},"load")," many times for the same state property, the ",(0,o.kt)("inlineCode",{parentName:"p"},"runtime")," will only execute the first loader."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// \u2705 fetchLocale is executed\nruntime.load("locale", fetchLocale);\n// \u274c fetchLocale is skipped\nruntime.load("locale", fetchLocale);\n// \u274c fetchLocale is skipped\nruntime.load("locale", fetchLocale);\n')),(0,o.kt)("h4",{id:"loaded"},(0,o.kt)("inlineCode",{parentName:"h4"},"loaded")),(0,o.kt)("p",null,"It's an async method that will await while a given state property is being loaded. If the state property is not being loaded it resolves immediately. Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'runtime.load("locale", () => Promise.resolve("es"));\n// in real-world project the next line would not be after the previous `load` call but in a different part of the codebase\nconst locale = await runtime.loaded("locale"); // locale equals "es"\n')),(0,o.kt)("p",null,"The previous code has the same effect as the following code. The reason for having ",(0,o.kt)("inlineCode",{parentName:"p"},"loaded")," is that in a distributed UI, the code that needs to ",(0,o.kt)("inlineCode",{parentName:"p"},"await")," might not be the same as the code that ",(0,o.kt)("inlineCode",{parentName:"p"},"load"),"s the value, unlike the following example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'const locale = await runtime.load("locale", () => Promise.resolve("es"));\n')),(0,o.kt)("p",null,"If ",(0,o.kt)("inlineCode",{parentName:"p"},"loaded")," is called with no state property then it awaits for all the loaders to resolve."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'runtime.load("locale", fetchLocale);\nruntime.load("token", fetchToken);\n\nawait runtime.loaded();\n// both locale and token have been loaded\n')),(0,o.kt)("h4",{id:"loader"},(0,o.kt)("inlineCode",{parentName:"h4"},"loader")),(0,o.kt)("p",null,"It returns the state of a loader: ",(0,o.kt)("inlineCode",{parentName:"p"},"loading: boolean")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"error?: string"),". Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'runtime.load("locale", fetchLocale);\n// runtime.loader.locale.loading is true\n\nawait runtime.loaded("locale");\n// runtime.loader.locale.loading is false\n\n// Heads up, make sure to await runtime.loaded("state_property") before checking if there is an error\nconst didError = runtime.loader.locale.error;\n// didError has an error message if the load method failed.\n')))}d.isMDXComponent=!0}}]);